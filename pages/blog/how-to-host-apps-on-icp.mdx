import Head from 'next/head'
import Image from 'next/image'
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faArrowLeft } from '@fortawesome/free-solid-svg-icons'
import NavBarBlog from '/components/NavBarBlog'
import styles from "../../styles/Blog.module.scss"
import STRINGS from '/public/strings.json'

<Head>
  <title>{`Blog | Internet Computer (ICP)`}</title>
  <meta name="description" content="This article discusses why hosting your web apps on the Internet Computer (ICP) might make sense and lists the steps to take to successfully launch your apps on ICP both locally and in production."/>
</Head>
<NavBarBlog />

<div className="section section-bg">
<div className="columns is-flex is-justify-content-center">
<div className="column is-9" style={{overflow:'auto'}}>

<h1 className="title is-3 has-text-primary"> {STRINGS.blogs.additional[1].title} </h1>

<div className="title is-4 has-text-info"> 
  {STRINGS.blogs.additional[1].date} - <span className="title is-5 has-text-info">12 min read</span>
</div>

<div className="container">
  <Image
    alt='the-internet-computer'
    src='/img/blog/blog2-internet-computer.webp'
    priority
    width={0}
    height={0}
    sizes="100vw"
    style={{objectFit:'cover',width:'100%',height:'250px'}}
  />
</div>

(*ICP represents a layer one public blockchain network that has captured the attention of innovators worldwide. Its defining feature is the novel consensus algorithm known as “Threshold Relay,” which combines the computing power of numerous independent data centers around the globe. This fusion creates a vast decentralized world computer, known as the <span className="has-text-weight-bold">Internet Computer</span>.*)

<div className={styles.blogParagraph}>

<h2>Jump to Section:</h2>

  * [What is the Internet Computer?](#what-is-icp)
  * [ICP Benefits and Capabilities](#icp-vs-cloud)
  * [Building and Running Locally](#build-and-run)
  * [Deploying to Production](#icp-deploy)
  * [Configuring a Custom Domain (Optional)](#custom-domain)

<h2 id="what-is-icp">What is the Internet Computer?</h2>

The Internet Computer (ICP) is a layer one public blockchain that offers numerous benefits including smart contracts that can serve web/HTTP at web speed. This allows developers to build decentralized applications (dApps) completely on-chain without the need for traditional cloud hosting services such as AWS and GCP. 

Additionally, the reverse gas model implemented on ICP ensures that dApp developers cover the computation costs, liberating users from the obligation of owning or managing tokens. Through the use of chainkey cryptography smart contracts on ICP can effortlessly control Bitcoin balances and can interact with contracts on Ethereum and vice versa, without the need for wrapping or bridging.

Developed by the [DFINITY Foundation](https://dfinity.org/), ICP uses consensus algorithm known as *Threshold Relay* which "*harmoniously combines the computing power of numerous independent data centers around the globe using ICP. This fusion creates a vast decentralized world computer*..." known today as the Internet Computer.

<h2 id="icp-vs-cloud">ICP Benefits and Capabilities</h2>

Hosting your applications on the Internet Computer offers several benefits when compared to competing blockchains as well as traditional cloud hosting services. 

<h3>Infinite Scaling</h3>

First, ICP offers infinite scaling capabilities, meaning the Internet Computer can host an unlimited number of [canisters](https://internetcomputer.org/docs/current/concepts/canisters-code) (smart contracts), store an unlimited amount of memory, and process an unlimited amount of transactions per second. In simple words, Internet Computer is designed to host even large scale social media platforms in a fully decentralized way.

<div className="container">
  <Image
    alt='icp-scaling-data'
    src='/img/blog/icp-scalability.jpeg'
    priority
    width={0}
    height={0}
    sizes="100vw"
    style={{ width: '100%', height: 'auto' }}
  />
  <div> <a href="https://forum.dfinity.org/t/unleashing-the-potential-of-internet-computer-icp-the-future-of-decentralized-innovation/20711">(Source)</a> </div>
</div>

<h3>Reverse Gas Model</h3>

A browser is all you need to interact with smart contracts on the Internet Computer. Canisters (i.e. ICP smart contracts) have the ability to serve web content directly to end users, meaning individuals can interact with blockchain services without the requirement of holding tokens. The reverse gas model implemented on ICP ensures that dApp developers cover the computation costs, liberating users from the obligation of owning or managing tokens.

On the other hand, this also means that developers need to learn how to purchase and secure ICP tokens to keep their dApps funded for hosting. There is a small learning curve and some hard to calculate forecasts developers need to make re: how much ICP is needed to fund their apps (especially once the app starts scaling). In general, ICP apps need *Cycles* in order to run so developers need to make a USD -> ICP -> Cycles conversion in order to properly run their apps. For more info see the [Tokens](https://internetcomputer.org/docs/current/concepts/tokens-cycles) page.

<h3>Cost Efficiency</h3>

Another noteworthy advantage of ICP lies in its cost efficiency. Storing 1GB of data on ICP costs approximately $5 per year, a stark contrast to Ethereum’s staggering $350,000,000 and Solana’s approximately $800,000 for the same storage capacity. This also counts as a benefit compared to traditional cloud services like AWS and GCP which have higher data storage costs (though not by as much).

<div className="container">
  <Image
    alt='icp-cost-efficiency'
    src='/img/blog/icp-cost-efficiency.jpeg'
    priority
    width={0}
    height={0}
    sizes="100vw"
    style={{ width: '100%', height: 'auto' }}
  />
  <div> <a href="https://forum.dfinity.org/t/unleashing-the-potential-of-internet-computer-icp-the-future-of-decentralized-innovation/20711">(Source)</a> </div>
</div>

<h3>100% Up-Time</h3>

While many developers reading this have heard the terms four- or five-9s, corresponding to 99.99% or 99.999% annual server up-time for a given service which is hard to achieve, the Internet Computer offers a fully autonomous and unstoppable cloud that  abstracts much of the required infrastructure and corresponding human expertise needed.

<h3>Additional Advantages</h3>

By utilizing a decentralized blockchain protocol the IC also enjoys other benefits  especially when compared to traditional cloud hosting services. For developers looking for serverless architecture the IC offers <span className="has-text-weight-bold">Serverless Computing</span>, enabling quick and agile development cycles that can greatly reduce infrastructure maintenance and operational costs.

The IC enjoys additional security benefits such as tamper-proof and unstoppable software systems and services that do not require safeguarding through firewalls, SIEM logging, or other conventional cybersecurity frameworks.

Additionally, chain-key cryptography and secure multiparty computation enable enterprise-grade custody of digital assets on the Internet Computer. Security built into the protocol reduces the complexity of digital asset custody associated with traditional solutions.


<h2 id="build-and-run">Building and Running Locally</h2>

I've migrated two of my apps to the Internet Computer so far and to my surprise generally found it a straight forward and simple process, which I believe is another advantage of the IC and helps add to its increasing popularity with developers.

<h3>Requirements</h3>

* DFINITY command-line execution environment (dfx) v0.15.2+
* Linux or MacOS (12+) development environment
* Node v20.11.0+

> As the 2nd requirement above states the IC SDK is natively supported on Linux or macOS 12 Monterey or later. As of this writing there is no native support for `dfx` on Windows; however by installing the Windows Subsystem for Linux (WSL 2), it's possible to run dfx on a Windows system (more [info](https://internetcomputer.org/docs/current/developer-docs/setup/install/#installing-the-ic-sdk-1)).

<h3>Download IC SDK</h3>

The DFINITY command-line execution environment (`dfx`) is the primary tool for creating, deploying, and managing the dApps you develop for the IC. Let's start by downloading the IC SDK locally:

```shell
sh -ci "$(curl -fsSL https://internetcomputer.org/install.sh)"
```

To verify the SDK is ready to use run the following command: 

```shell
dfx --version
```

For general SDK usage information and commands run:

```shell
dfx --help
```

<h3>Local Canister Execution Environment</h3>

For simplicity, we will first build and deploy a "Hello World" project locally. Once that's running it's a straight forward process for replacing the app's source with the source code of an app you want to migrate and host on the IC.

With the `dfx` SDK downloaded the first thing we want to do is start a local replica instance (The *--background* flag will start the replica in the background and return your terminal prompt for more commands):

```shell
dfx start --background
```

You should see output similar to the following:

```shell
Running dfx start for version 0.15.3
Using the default definition for the 'local' shared network because /Users/user/.config/dfx/networks.json does not exist.
Initialized replica.
Dashboard: http://localhost:55762/_/dashboard
```

Next we use the `dfx new` command to create a basic Hello World project:

```shell
dfx new hello_world
```

This creates a "Hello, world!" project that contains a basic frontend UI (for a full, detailed guide on this project see [here](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally#test-the-dapp-frontend)). The project structure of this app should look similar to the following:

```
hello_world/
├── README.md      # Default project documentation
├── dfx.json       # Project configuration file
├── node_modules   # Libraries for frontend development
├── package-lock.json
├── package.json
├── src            # Source files directory
│   ├── hello_world_backend
│   │   └── main.mo
│   ├── hello_world_frontend
│       ├── assets
│       │   ├── logo.png
│       │   ├── main.css
│       │   └── sample-asset.txt
│       └── src
│           ├── index.html
│           └── index.js
└── webpack.config.js
```

Now we can build and deploy the project <span className="has-text-weight-bold">locally</span> using the `dfx deploy` command: 

```shell
cd hello_world
dfx deploy
```

Upon successful execution, the project URL(s) will be returned in the output (e.g.):

```shell
...
Committing batch.
Committing batch with 18 operations.
Deployed canisters.
URLs:
  Frontend canister via browser
    hello_world_frontend: http://127.0.0.1:4943/?canisterId=a4tbr-q4aaa-aaaaa-qaafq-cai
  Backend canister via Candid interface:
    hello_world_backend: http://127.0.0.1:4943/?canisterId=ajuq4-ruaaa-aaaaa-qaaga-cai&id=a3shf-5eaaa-aaaaa-qaafa-cai
```

You can now view the running app by accessing the frontend URL in a browser, for example:

```properties
http://127.0.0.1:4943/?canisterId=a4tbr-q4aaa-aaaaa-qaafq-cai
```

Assuming no errors you now have an IC app running against your local canister execution environment.

> By default, all `dfx` commands run against the local environment. To run any command in production add the *--network ic* flag (or *--ic* for shorthand). For example, when ready to deploy to production we would do `dfx deploy --network ic`.

<h3 id="config-ic-hosting">Configure Your App for IC Hosting</h3>

With the template project successfully running, hopefully you have a better understanding of how to run and deploy apps on the Internet Computer. But what if you want to test your own app(s) on the IC instead of the Hello World template? Well the good news is that's there's two basic steps:

1. Add a `dfx.json` configuration file to the root folder of your application.
2. Configure your dfx.json file to point to the proper entrypoint and output locations of your app.

Start by copying the `dfx.json` file that we created above, which should look similar to the following:

```json
{
  "canisters": {
    "hello_world_backend": {
      "main": "src/hello_world_backend/main.mo",
      "type": "motoko"
    },
    "hello_world_frontend": {
      "dependencies": [
        "hello_world_backend"
      ],
      "frontend": {
        "entrypoint": "src/hello_world_frontend/src/index.html"
      },
      "source": [
        "src/hello_world_frontend/assets",
        "dist/hello_world_frontend/"
      ],
      "type": "assets"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "output_env_file": ".env",
  "version": 1
}
```

Next update the file to point to the source and entrypoint locations of your frontend and backend applications. Note that the canister names, *hello_world_backend* and *hello_world_frontend* in the above example, are user-defined.

If your app only contains a frontend then you simply need to specify that part of the configuration, for example:

```json
{
  "canisters": {
    "my_website_fe": {
      "frontend": {
        "entrypoint": "build/index.html"
      },
      "source": ["build"],
      "type": "assets"
    }
  }
}
```

> The above example assumes frontend static assets are contained in a folder named `/build` located at the root of the project. For example, when using Create React App (CRA) by default optimized production builds are created under the */build* folder.

With all proper paths and references updated in your <span className="has-text-weight-bold">dfx.json</span> file you can build and deploy your project locally using:

```shell
dfx deploy
```

Once your app is successfully running in the local environment and you're ready to deploy to production you'll need to acquire and add ICP cycles to your canister(s).

<h2 id="icp-deploy">Deploying to Production</h2>

When you are ready to deploy your app to production - i.e. the Internet Computer [mainnet](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-mainnet) - you will first need to add cycles to power your app's storage and compute costs.

If you already have enough cycles available in your production wallet you can issue the following command to deploy you app to production: 

```shell
dfx deploy --network ic
```

or shorthand:

```shell
dfx deploy --ic
```

If you do not have enough cycles to power your app you will need to add more to your production wallet by obtaining new ICP tokens and [converting into cycles](https://internetcomputer.org/docs/current/developer-docs/setup/cycles/) as mentioned above.

{/* 
<h3>Aquire ICP Cycles</h3>

Canister smart contracts are obligated to compensate for the resources they utilize, including storage and compute power. Instead of using ICP tokens, the payment for resource consumption is made in [Cycles](https://internetcomputer.org/docs/current/developer-docs/setup/cycles/). Typically, it is the developer of the canister who allocates cycles to it. As the canister is employed, its cycle balance gradually diminishes, requiring periodic replenishment.

> Unlike ICP tokens, cycles are only associated with canisters and not with user or developer principals. Because only canisters require cycles to perform operations and pay for the resources they use, users and developers manage the distribution and ownership of cycles through a special type of canister called a <span className="has-text-weight-bold">Cycles Wallet</span>.

When testing against a local canister execution environment, the SDK automatically generates a default cycles wallet for each project, and the majority of operations with the cycles wallet occur seamlessly in the background.




The biggest difference between local and production deployments are that production apps require cycles to run (this is automatically handled for you in the local environment as described below). This means you'll need to purchase or otherwise aquire ICP tokens and convert them into cycles for your production apps. The other difference is that we will be issuing our `dfx` commands with the production flag, for example `dfx deploy --network ic` or `dfx deploy --ic` for shorthand.

*/}


<h2 id="custom-domain">Configuring a Custom Domain (Optional)</h2>

If you want to make a canister accessible through a custom domain DFINITY actually has a decent [guide](https://internetcomputer.org/docs/current/developer-docs/production/custom-domain/) that walks you through the process. However I still encountered numerous problems and issues that I wanted to highlight here.

There are two approaches for configuring a cansister to work with a custom domain:

1. Register the domain with the boundary nodes
2. Host the domain on your own infrasture

Here we will follow the first approach of <span className="has-text-weight-bold">Registering the Domain with the Boundary Nodes</span>. If you want to host the domain on your own infrastucture see [here](https://internetcomputer.org/docs/current/developer-docs/production/custom-domain/#custom-domains-using-your-own-infrastructure).

The general steps for registering your custom domain are:

1. Configure custom DNS records for the custom domain.
2. Add `.well-known/ic-domains` and `.ic-assets.json` config files to your project.
3. Deploy your canister.
4. Register the domain with boundary nodes.

<h3>1. Configure DNS Records </h3>

Let's say you want to register a custom domain `foo.bar.com`, first add the following DNS records through your domain provider:

<table className="table">
  <thead>
    <tr>
      <th>Record Type</th>
      <th>Host</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td className="tableTitle">CNAME</td>
      <td>foo.bar.com</td>
      <td>icp1.io</td>
    </tr>
    <tr>
      <td className="tableTitle">TXT</td>
      <td>_canister-id.foo.bar.com</td>
      <td>_acme-challenge.foo.bar.com</td>
    </tr>
    <tr>
      <td className="tableTitle">CNAME</td>
      <td>hwvjt-wqaaa-aaaam-qadra-cai</td>
      <td>_acme-challenge.foo.bar.com.icp2.io</td>
    </tr>
  </tbody>
</table>

You may need to wait minutes or even hours for the DNS changes to propogate out. Next you'll need to add two new configuration files to your project.

<h3>2. Add `.well-known/ic-domains` and `.ic-assets.json` files </h3>

The next step seems obvious but can be tricky based on which framework you are using for your project and how it creates production builds. First you need to create two new files, one in a hidden folder and a second hidden file at the root of your canister source folder:

```shell
mkdir .well-known
```

Next using your editor create a `.well-known/ic-domains` file and add the following contents to the file:

```
foo.bar.com
```

Now create a `.ic-assets.json` file which contains the following:

```json
[
    {
        "match": ".well-known",
        "ignore": false
    }
]
```

One potentially tricky issue here is that the DFINITY documentation states these two files should be added to your "*canister source root*". This might be clear for backend projects, however for frontend projects using React or Next.js it can be misleading.

As was covered [earlier in this article](#config-ic-hosting), when we initially configured our project for IC hosting we added a `dfx.json` file to the project root that specifies entrypoints and source locations for canister(s). A simpler version of this file that works for frontend projects is:

```json
{
  "canisters": {
    "my_website_fe": {
      "frontend": {
        "entrypoint": "build/index.html"
      },
      "source": ["build"],
      "type": "assets"
    }
  }
}
```

With regards to the `.well-known/ic-domains` and `.ic-assets.json` files these files would need to be included in the `/build` folder in the example above. 

For React or Next.js developers, this means you'll need to add the `.well-known/ic-domains` and `.ic-assets.json` files to the `/public` folder at your project root and rely on your framework's build process to properly include them in the optimized build output.

<h3>3. Deploy your Canister </h3>

With your DNS records configured and above configuration files properly added to your project you'll need to re-deploy your canister to the IC. To deploy to production IC do:

```shell
dfx deploy --ic
```

Assuming successfull deploy the last step is to register the custom domain.

<h3>4. Register Domain with Boundary Nodes </h3>

To start the registration process for domain `foo.bar.com` issue the following command:

```shell
curl -sLv -X POST \
    -H 'Content-Type: application/json' \
    https://icp0.io/registrations \
    --data @- <<EOF
{
    "name": "foo.bar.com"
}
EOF
```

If the call was successfull the response will look like:

```json
{"id":"REQUEST_ID"}
```

For help dealing with potential errors see [here](https://internetcomputer.org/docs/current/developer-docs/production/custom-domain/#step-3-register-the-domain-with-the-boundary-nodes-by-issuing-the-following-command-and-replacing-custom_domain-with-your-custom-domain).

You may need to wait a few minutes for the certificates to become available across the boundary nodes but once they do you should be able to access your canister application by navigating to your custom domain!

<hr />

Thanks for reading!

<div className="title is-5 has-text-info"> 
  <span className="title is-5 has-text-info">by {STRINGS.blogAuthors[0].author} ({STRINGS.blogs.additional[1].date})</span>
</div>

</div>
</div>
</div>
</div>